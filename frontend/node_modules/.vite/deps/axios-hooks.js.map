{
  "version": 3,
  "sources": ["../../@babel/runtime/helpers/typeof.js", "../../@babel/runtime/helpers/regeneratorRuntime.js", "../../@babel/runtime/regenerator/index.js", "../../@babel/runtime/helpers/esm/asyncToGenerator.js", "../../@babel/runtime/helpers/esm/extends.js", "../../axios-hooks/es/index.js", "../../axios-hooks/node_modules/lru-cache/src/index.ts", "../../dequal/lite/index.mjs"],
  "sourcesContent": ["function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction _regeneratorRuntime() {\n  \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {\n    return e;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  var t,\n    e = {},\n    r = Object.prototype,\n    n = r.hasOwnProperty,\n    o = Object.defineProperty || function (t, e, r) {\n      t[e] = r.value;\n    },\n    i = \"function\" == typeof Symbol ? Symbol : {},\n    a = i.iterator || \"@@iterator\",\n    c = i.asyncIterator || \"@@asyncIterator\",\n    u = i.toStringTag || \"@@toStringTag\";\n  function define(t, e, r) {\n    return Object.defineProperty(t, e, {\n      value: r,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), t[e];\n  }\n  try {\n    define({}, \"\");\n  } catch (t) {\n    define = function define(t, e, r) {\n      return t[e] = r;\n    };\n  }\n  function wrap(t, e, r, n) {\n    var i = e && e.prototype instanceof Generator ? e : Generator,\n      a = Object.create(i.prototype),\n      c = new Context(n || []);\n    return o(a, \"_invoke\", {\n      value: makeInvokeMethod(t, r, c)\n    }), a;\n  }\n  function tryCatch(t, e, r) {\n    try {\n      return {\n        type: \"normal\",\n        arg: t.call(e, r)\n      };\n    } catch (t) {\n      return {\n        type: \"throw\",\n        arg: t\n      };\n    }\n  }\n  e.wrap = wrap;\n  var h = \"suspendedStart\",\n    l = \"suspendedYield\",\n    f = \"executing\",\n    s = \"completed\",\n    y = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var p = {};\n  define(p, a, function () {\n    return this;\n  });\n  var d = Object.getPrototypeOf,\n    v = d && d(d(values([])));\n  v && v !== r && n.call(v, a) && (p = v);\n  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);\n  function defineIteratorMethods(t) {\n    [\"next\", \"throw\", \"return\"].forEach(function (e) {\n      define(t, e, function (t) {\n        return this._invoke(e, t);\n      });\n    });\n  }\n  function AsyncIterator(t, e) {\n    function invoke(r, o, i, a) {\n      var c = tryCatch(t[r], t, o);\n      if (\"throw\" !== c.type) {\n        var u = c.arg,\n          h = u.value;\n        return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) {\n          invoke(\"next\", t, i, a);\n        }, function (t) {\n          invoke(\"throw\", t, i, a);\n        }) : e.resolve(h).then(function (t) {\n          u.value = t, i(u);\n        }, function (t) {\n          return invoke(\"throw\", t, i, a);\n        });\n      }\n      a(c.arg);\n    }\n    var r;\n    o(this, \"_invoke\", {\n      value: function value(t, n) {\n        function callInvokeWithMethodAndArg() {\n          return new e(function (e, r) {\n            invoke(t, n, e, r);\n          });\n        }\n        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n    });\n  }\n  function makeInvokeMethod(e, r, n) {\n    var o = h;\n    return function (i, a) {\n      if (o === f) throw Error(\"Generator is already running\");\n      if (o === s) {\n        if (\"throw\" === i) throw a;\n        return {\n          value: t,\n          done: !0\n        };\n      }\n      for (n.method = i, n.arg = a;;) {\n        var c = n.delegate;\n        if (c) {\n          var u = maybeInvokeDelegate(c, n);\n          if (u) {\n            if (u === y) continue;\n            return u;\n          }\n        }\n        if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) {\n          if (o === h) throw o = s, n.arg;\n          n.dispatchException(n.arg);\n        } else \"return\" === n.method && n.abrupt(\"return\", n.arg);\n        o = f;\n        var p = tryCatch(e, r, n);\n        if (\"normal\" === p.type) {\n          if (o = n.done ? s : l, p.arg === y) continue;\n          return {\n            value: p.arg,\n            done: n.done\n          };\n        }\n        \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg);\n      }\n    };\n  }\n  function maybeInvokeDelegate(e, r) {\n    var n = r.method,\n      o = e.iterator[n];\n    if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y;\n    var i = tryCatch(o, e.iterator, r.arg);\n    if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y;\n    var a = i.arg;\n    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y);\n  }\n  function pushTryEntry(t) {\n    var e = {\n      tryLoc: t[0]\n    };\n    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n  }\n  function resetTryEntry(t) {\n    var e = t.completion || {};\n    e.type = \"normal\", delete e.arg, t.completion = e;\n  }\n  function Context(t) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], t.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(e) {\n    if (e || \"\" === e) {\n      var r = e[a];\n      if (r) return r.call(e);\n      if (\"function\" == typeof e.next) return e;\n      if (!isNaN(e.length)) {\n        var o = -1,\n          i = function next() {\n            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;\n            return next.value = t, next.done = !0, next;\n          };\n        return i.next = i;\n      }\n    }\n    throw new TypeError(_typeof(e) + \" is not iterable\");\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: !0\n  }), o(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: !0\n  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) {\n    var e = \"function\" == typeof t && t.constructor;\n    return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name));\n  }, e.mark = function (t) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t;\n  }, e.awrap = function (t) {\n    return {\n      __await: t\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {\n    return this;\n  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {\n    void 0 === i && (i = Promise);\n    var a = new AsyncIterator(wrap(t, r, n, o), i);\n    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {\n      return t.done ? t.value : a.next();\n    });\n  }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () {\n    return this;\n  }), define(g, \"toString\", function () {\n    return \"[object Generator]\";\n  }), e.keys = function (t) {\n    var e = Object(t),\n      r = [];\n    for (var n in e) r.push(n);\n    return r.reverse(), function next() {\n      for (; r.length;) {\n        var t = r.pop();\n        if (t in e) return next.value = t, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, e.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(e) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);\n    },\n    stop: function stop() {\n      this.done = !0;\n      var t = this.tryEntries[0].completion;\n      if (\"throw\" === t.type) throw t.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(e) {\n      if (this.done) throw e;\n      var r = this;\n      function handle(n, o) {\n        return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o;\n      }\n      for (var o = this.tryEntries.length - 1; o >= 0; --o) {\n        var i = this.tryEntries[o],\n          a = i.completion;\n        if (\"root\" === i.tryLoc) return handle(\"end\");\n        if (i.tryLoc <= this.prev) {\n          var c = n.call(i, \"catchLoc\"),\n            u = n.call(i, \"finallyLoc\");\n          if (c && u) {\n            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n          } else if (c) {\n            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n          } else {\n            if (!u) throw Error(\"try statement without catch or finally\");\n            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(t, e) {\n      for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n        var o = this.tryEntries[r];\n        if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) {\n          var i = o;\n          break;\n        }\n      }\n      i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);\n      var a = i ? i.completion : {};\n      return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a);\n    },\n    complete: function complete(t, e) {\n      if (\"throw\" === t.type) throw t.arg;\n      return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y;\n    },\n    finish: function finish(t) {\n      for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n        var r = this.tryEntries[e];\n        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;\n      }\n    },\n    \"catch\": function _catch(t) {\n      for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n        var r = this.tryEntries[e];\n        if (r.tryLoc === t) {\n          var n = r.completion;\n          if (\"throw\" === n.type) {\n            var o = n.arg;\n            resetTryEntry(r);\n          }\n          return o;\n        }\n      }\n      throw Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(e, r, n) {\n      return this.delegate = {\n        iterator: values(e),\n        resultName: r,\n        nextLoc: n\n      }, \"next\" === this.method && (this.arg = t), y;\n    }\n  }, e;\n}\nmodule.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "// TODO(Babel 8): Remove this file.\n\nvar runtime = require(\"../helpers/regeneratorRuntime\")();\nmodule.exports = runtime;\n\n// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n", "function asyncGeneratorStep(n, t, e, r, o, a, c) {\n  try {\n    var i = n[a](c),\n      u = i.value;\n  } catch (n) {\n    return void e(n);\n  }\n  i.done ? t(u) : Promise.resolve(u).then(r, o);\n}\nfunction _asyncToGenerator(n) {\n  return function () {\n    var t = this,\n      e = arguments;\n    return new Promise(function (r, o) {\n      var a = n.apply(t, e);\n      function _next(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n);\n      }\n      function _throw(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n);\n      }\n      _next(void 0);\n    });\n  };\n}\nexport { _asyncToGenerator as default };", "function _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nexport { _extends as default };", "import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport React from 'react';\nimport StaticAxios, { isCancel } from 'axios';\nimport { LRUCache } from 'lru-cache';\nimport { dequal as deepEqual } from 'dequal/lite';\nvar actions = {\n  REQUEST_START: 'REQUEST_START',\n  REQUEST_END: 'REQUEST_END'\n};\nvar DEFAULT_OPTIONS = {\n  manual: false,\n  useCache: true,\n  ssr: true,\n  autoCancel: true\n};\nvar useAxios = makeUseAxios();\nvar __ssrPromises = useAxios.__ssrPromises,\n  resetConfigure = useAxios.resetConfigure,\n  configure = useAxios.configure,\n  loadCache = useAxios.loadCache,\n  serializeCache = useAxios.serializeCache,\n  clearCache = useAxios.clearCache;\nexport default useAxios;\nexport { __ssrPromises, resetConfigure, configure, loadCache, serializeCache, clearCache };\nfunction isReactEvent(obj) {\n  return obj && obj.nativeEvent && obj.nativeEvent instanceof Event;\n}\nfunction createCacheKey(config) {\n  var cleanedConfig = _extends({}, config);\n  delete cleanedConfig.cancelToken;\n  return JSON.stringify(cleanedConfig);\n}\nfunction configToObject(config) {\n  if (typeof config === 'string') {\n    return {\n      url: config\n    };\n  }\n  return Object.assign({}, config);\n}\nexport function makeUseAxios(configureOptions) {\n  /**\n   * @type {import('lru-cache')}\n   */\n  var cache;\n  var axiosInstance;\n  var defaultOptions;\n  var __ssrPromises = [];\n  function resetConfigure() {\n    cache = new LRUCache({\n      max: 500\n    });\n    axiosInstance = StaticAxios;\n    defaultOptions = DEFAULT_OPTIONS;\n  }\n  function configure(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (options.axios !== undefined) {\n      axiosInstance = options.axios;\n    }\n    if (options.cache !== undefined) {\n      cache = options.cache;\n    }\n    if (options.defaultOptions !== undefined) {\n      defaultOptions = _extends({}, DEFAULT_OPTIONS, options.defaultOptions);\n    }\n  }\n  resetConfigure();\n  configure(configureOptions);\n  function loadCache(data) {\n    cache.load(data);\n  }\n  function serializeCache() {\n    return _serializeCache.apply(this, arguments);\n  }\n  function _serializeCache() {\n    _serializeCache = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var ssrPromisesCopy;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            ssrPromisesCopy = [].concat(__ssrPromises);\n            __ssrPromises.length = 0;\n            _context.next = 4;\n            return Promise.all(ssrPromisesCopy);\n          case 4:\n            return _context.abrupt(\"return\", cache.dump());\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return _serializeCache.apply(this, arguments);\n  }\n  function clearCache() {\n    cache.clear();\n  }\n  return Object.assign(useAxios, {\n    __ssrPromises: __ssrPromises,\n    resetConfigure: resetConfigure,\n    configure: configure,\n    loadCache: loadCache,\n    serializeCache: serializeCache,\n    clearCache: clearCache\n  });\n  function tryStoreInCache(config, response) {\n    if (!cache) {\n      return;\n    }\n    var cacheKey = createCacheKey(config);\n    var responseForCache = _extends({}, response);\n    delete responseForCache.config;\n    delete responseForCache.request;\n    cache.set(cacheKey, responseForCache);\n  }\n  function createInitialState(config, options) {\n    var response = !options.manual && tryGetFromCache(config, options);\n    return _extends({\n      loading: !options.manual && !response,\n      error: null\n    }, response ? {\n      data: response.data,\n      response: response\n    } : null);\n  }\n  function reducer(state, action) {\n    var _extends2;\n    switch (action.type) {\n      case actions.REQUEST_START:\n        return _extends({}, state, {\n          loading: true,\n          error: null\n        });\n      case actions.REQUEST_END:\n        return _extends({}, state, {\n          loading: false\n        }, action.error ? {} : {\n          data: action.payload.data,\n          error: null\n        }, (_extends2 = {}, _extends2[action.error ? 'error' : 'response'] = action.payload, _extends2));\n    }\n  }\n  function tryGetFromCache(config, options, dispatch) {\n    if (!cache || !options.useCache) {\n      return;\n    }\n    var cacheKey = createCacheKey(config);\n    var response = cache.get(cacheKey);\n    if (response && dispatch) {\n      dispatch({\n        type: actions.REQUEST_END,\n        payload: response\n      });\n    }\n    return response;\n  }\n  function executeRequest(_x, _x2) {\n    return _executeRequest.apply(this, arguments);\n  }\n  function _executeRequest() {\n    _executeRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(config, dispatch) {\n      var response;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            dispatch({\n              type: actions.REQUEST_START\n            });\n            _context2.next = 4;\n            return axiosInstance(config);\n          case 4:\n            response = _context2.sent;\n            tryStoreInCache(config, response);\n            dispatch({\n              type: actions.REQUEST_END,\n              payload: response\n            });\n            return _context2.abrupt(\"return\", response);\n          case 10:\n            _context2.prev = 10;\n            _context2.t0 = _context2[\"catch\"](0);\n            if (!isCancel(_context2.t0)) {\n              dispatch({\n                type: actions.REQUEST_END,\n                payload: _context2.t0,\n                error: true\n              });\n            }\n            throw _context2.t0;\n          case 14:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[0, 10]]);\n    }));\n    return _executeRequest.apply(this, arguments);\n  }\n  function request(_x3, _x4, _x5) {\n    return _request.apply(this, arguments);\n  }\n  function _request() {\n    _request = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(config, options, dispatch) {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", tryGetFromCache(config, options, dispatch) || executeRequest(config, dispatch));\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }));\n    return _request.apply(this, arguments);\n  }\n  function useAxios(_config, _options) {\n    var config = React.useMemo(function () {\n      return configToObject(_config);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    useDeepCompareMemoize(_config));\n    var options = React.useMemo(function () {\n      return _extends({}, defaultOptions, _options);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    useDeepCompareMemoize(_options));\n    var abortControllerRef = React.useRef();\n    var _React$useReducer = React.useReducer(reducer, createInitialState(config, options)),\n      state = _React$useReducer[0],\n      dispatch = _React$useReducer[1];\n    if (typeof window === 'undefined' && options.ssr && !options.manual) {\n      useAxios.__ssrPromises.push(axiosInstance(config));\n    }\n    var cancelOutstandingRequest = React.useCallback(function () {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    }, []);\n    var withAbortSignal = React.useCallback(function (config) {\n      if (options.autoCancel) {\n        cancelOutstandingRequest();\n      }\n      abortControllerRef.current = new AbortController();\n      config.signal = abortControllerRef.current.signal;\n      return config;\n    }, [cancelOutstandingRequest, options.autoCancel]);\n    React.useEffect(function () {\n      if (!options.manual) {\n        request(withAbortSignal(config), options, dispatch)[\"catch\"](function () {});\n      }\n      return function () {\n        if (options.autoCancel) {\n          cancelOutstandingRequest();\n        }\n      };\n    }, [config, options, withAbortSignal, cancelOutstandingRequest]);\n    var refetch = React.useCallback(function (configOverride, options) {\n      configOverride = configToObject(configOverride);\n      return request(withAbortSignal(_extends({}, config, isReactEvent(configOverride) ? null : configOverride)), _extends({\n        useCache: false\n      }, options), dispatch);\n    }, [config, withAbortSignal]);\n    return [state, refetch, cancelOutstandingRequest];\n  }\n}\nfunction useDeepCompareMemoize(value) {\n  var ref = React.useRef();\n  var signalRef = React.useRef(0);\n  if (!deepEqual(value, ref.current)) {\n    ref.current = value;\n    signalRef.current += 1;\n  }\n  return [signalRef.current];\n}", "/**\n * @module LRUCache\n */\n\n// module-private names and types\n// this provides the default Perf object source.\n// it can be passed in via configuration to override it\n// for a single LRU object.\nexport type Perf = { now: () => number }\nconst defaultPerf: Perf =\n  (\n    typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n  ) ?\n    performance\n  : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ?\n    process\n  : {}) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC,\n) => {\n  typeof PROCESS.emitWarning === 'function' ?\n    PROCESS.emitWarning(msg, type, code, fn)\n  : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill,\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max) ? null\n  : max <= Math.pow(2, 8) ? Uint8Array\n  : max <= Math.pow(2, 16) ? Uint16Array\n  : max <= Math.pow(2, 32) ? Uint32Array\n  : max <= Number.MAX_SAFE_INTEGER ? ZeroArray\n  : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(max: number, HeapCls: { new (n: number): NumberArray }) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason,\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason,\n  ) => void\n\n  /**\n   * The reason why an item was added to the cache, passed\n   * to the {@link Inserter} methods.\n   *\n   * - `add`: the item was not found in the cache, and was added\n   * - `update`: the item was in the cache, with the same value provided\n   * - `replace`: the item was in the cache, and replaced\n   */\n  export type InsertReason = 'add' | 'update' | 'replace'\n\n  /**\n   * A method called upon item insertion, passed as the\n   * {@link OptionsBase.insert}\n   */\n  export type Inserter<K, V> = (\n    value: V,\n    key: K,\n    reason: InsertReason,\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>,\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>,\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * Function that is called when new items are inserted into the cache,\n     * as `onInsert(value, key, reason)`.\n     *\n     * This can be useful if you need to perform actions when an item is\n     * added, such as logging or tracking insertions.\n     *\n     * Unlike some other options, this may _not_ be overridden by passing\n     * an option to `set()`, for performance and consistency reasons.\n     */\n    onInsert?: Inserter<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n\n    /**\n     * In some cases, you may want to swap out the performance/Date object\n     * used for TTL tracking. This should almost certainly NOT be done in\n     * production environments!\n     *\n     * This value defaults to `global.performance` if it has a `now()` method,\n     * or the `global.Date` object otherwise.\n     */\n    perf?: Perf\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown> {\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #onInsert?: LRUCache.Inserter<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n  readonly #perf: Perf\n\n  /**\n   * {@link LRUCache.OptionsBase.perf}\n   */\n  get perf() {\n    return this.#perf\n  }\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n  #autopurgeTimers?: (undefined | ReturnType<typeof setTimeout>)[]\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n  #hasOnInsert: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown,\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      autopurgeTimers: c.#autopurgeTimers,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any,\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context,\n        ),\n      moveToTail: (index: number): void => c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) => c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) => c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.onInsert} (read-only)\n   */\n  get onInsert() {\n    return this.#onInsert\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      onInsert,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      perf,\n    } = options\n\n    if (perf !== undefined) {\n      if (typeof perf?.now !== 'function') {\n        throw new TypeError(\n          'perf option must have a now() method if specified',\n        )\n      }\n    }\n\n    this.#perf = perf ?? defaultPerf\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize',\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (memoMethod !== undefined && typeof memoMethod !== 'function') {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {\n      throw new TypeError('fetchMethod must be a function if specified')\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof onInsert === 'function') {\n      this.#onInsert = onInsert\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasOnInsert = !!this.#onInsert\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified',\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified',\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError('ttl must be a positive integer if specified')\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required',\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n    const purgeTimers =\n      this.ttlAutopurge ?\n        new Array<undefined | ReturnType<typeof setTimeout>>(this.#max)\n      : undefined\n    this.#autopurgeTimers = purgeTimers\n\n    this.#setItemTTL = (index, ttl, start = this.#perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      // clear out the purge timer if we're setting TTL to 0, and\n      // previously had a ttl purge timer running, so it doesn't\n      // fire unnecessarily.\n      if (purgeTimers?.[index]) {\n        clearTimeout(purgeTimers[index])\n        purgeTimers[index] = undefined\n      }\n      if (ttl !== 0 && purgeTimers) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n        purgeTimers[index] = t\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? this.#perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = this.#perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(() => (cachedNow = 0), this.ttlResolution)\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void = () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds,\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)',\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.',\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>,\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>,\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>,\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>,\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache',\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {},\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this,\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this,\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    /* c8 ignore start - this isn't tested for the info function,\n     * but it's the same logic as found in other places. */\n    const value: V | undefined =\n      this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n    if (value === undefined) return undefined\n    /* c8 ignore end */\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (this.#perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined =\n        this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = this.#perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = this.#perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {},\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation,\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0 ? this.#tail\n        : this.#free.length !== 0 ? this.#free.pop()\n        : this.#size === this.#max ? this.#evict(false)\n        : this.#size) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n      if (this.#hasOnInsert) {\n        this.#onInsert?.(v as V, k, 'add')\n      }\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal) ?\n              oldVal.__staleWhileFetching\n            : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n\n      if (this.#hasOnInsert) {\n        this.onInsert?.(v as V, k, v === oldVal ? 'update' : 'replace')\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    if (this.#autopurgeTimers?.[head]) {\n      clearTimeout(this.#autopurgeTimers[head])\n      this.#autopurgeTimers[head] = undefined\n    }\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (index === undefined || (!allowStale && this.#isStale(index))) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any,\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (v: V | undefined, updateCache = false): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      const proceed = options.ignoreFetchAbort ||\n        !!(options.allowStaleOnFetchAbort && v !== undefined)\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason, proceed)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      // if nothing else has been written there but we're set to update the\n      // cache and ignore the abort, or if it's still pending on this specific\n      // background request, then write it to the cache.\n      const vl = this.#valList[index as Index]\n      if (vl === p || (ignoreAbort && updateCache && vl === undefined)) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching !== undefined) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      // do not pass go, do not collect $200\n      return fetchFail(er, false)\n    }\n\n    const fetchFail = (er: any, proceed: boolean): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete ||\n          !proceed && bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void,\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC ? LRUCache.FetchOptions<K, V, FC>\n    : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V>\n    : LRUCache.FetchOptionsWithContext<K, V, FC>,\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC ? K\n    : FC extends undefined | void ? K\n    : never,\n    fetchOptions?: unknown extends FC ? LRUCache.FetchOptions<K, V, FC>\n    : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V>\n    : never,\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {},\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale = allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link LRUCache.OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC ? LRUCache.FetchOptions<K, V, FC>\n    : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V>\n    : LRUCache.FetchOptionsWithContext<K, V, FC>,\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC ? K\n    : FC extends undefined | void ? K\n    : never,\n    fetchOptions?: unknown extends FC ? LRUCache.FetchOptions<K, V, FC>\n    : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V>\n    : never,\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {},\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>,\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC ? LRUCache.MemoOptions<K, V, FC>\n    : FC extends undefined | void ? LRUCache.MemoOptionsNoContext<K, V>\n    : LRUCache.MemoOptionsWithContext<K, V, FC>,\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC ? K\n    : FC extends undefined | void ? K\n    : never,\n    memoOptions?: unknown extends FC ? LRUCache.MemoOptions<K, V, FC>\n    : FC extends undefined | void ? LRUCache.MemoOptionsNoContext<K, V>\n    : never,\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index,\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        if (this.#autopurgeTimers?.[index]) {\n          clearTimeout(this.#autopurgeTimers?.[index])\n          this.#autopurgeTimers[index] = undefined\n        }\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n      for (const t of this.#autopurgeTimers ?? []) {\n        if (t !== undefined) clearTimeout(t)\n      }\n      this.#autopurgeTimers?.fill(undefined)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n", "var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n"],
  "mappings": "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",
  "names": ["o", "_regeneratorRuntime", "t", "e", "r", "a", "define", "n", "i", "c", "y", "o", "u", "h", "p", "a", "n", "defaultPerf", "warned", "PROCESS", "emitWarning", "msg", "type", "code", "fn", "AC", "AS", "_", "warnACPolyfill", "reason", "printACPolyfillWarning", "shouldWarn", "isPosInt", "n", "getUintArray", "max", "ZeroArray", "size", "Stack", "_Stack", "#constructing", "HeapCls", "s", "LRUCache", "_LRUCache", "#max", "#maxSize", "#dispose", "#onInsert", "#disposeAfter", "#fetchMethod", "#memoMethod", "#perf", "#size", "#calculatedSize", "#keyMap", "#keyList", "#valList", "#next", "#prev", "#head", "#tail", "#free", "#disposed", "#sizes", "#starts", "#ttls", "#autopurgeTimers", "#hasDispose", "#hasFetchMethod", "#hasDisposeAfter", "#hasOnInsert", "c", "p", "#isBackgroundFetch", "k", "index", "options", "context", "#backgroundFetch", "#moveToTail", "#indexes", "#rindexes", "#isStale", "ttl", "ttlResolution", "ttlAutopurge", "updateAgeOnGet", "updateAgeOnHas", "allowStale", "dispose", "onInsert", "disposeAfter", "noDisposeOnSet", "noUpdateTTL", "maxSize", "maxEntrySize", "sizeCalculation", "fetchMethod", "memoMethod", "noDeleteOnFetchRejection", "noDeleteOnStaleGet", "allowStaleOnFetchRejection", "allowStaleOnFetchAbort", "ignoreFetchAbort", "perf", "defaultPerf", "UintArray", "#initializeSizeTracking", "#initializeTTLTracking", "code", "shouldWarn", "warned", "emitWarning", "key", "ttls", "starts", "purgeTimers", "#setItemTTL", "start", "t", "#delete", "#updateItemAge", "#statusTTL", "status", "cachedNow", "getNow", "age", "sizes", "#removeItemSize", "#requireSize", "v", "#addItemSize", "#evict", "_i", "_s", "_st", "_k", "_v", "i", "#isValidIndex", "fn", "getOptions", "value", "thisp", "deleted", "entry", "remain", "arr", "setOptions", "oldVal", "oldValue", "dt", "task", "val", "free", "head", "hasOptions", "peekOptions", "ac", "AC", "signal", "fetchOpts", "cb", "updateCache", "aborted", "ignoreAbort", "proceed", "fetchFail", "bf", "vl", "eb", "er", "allowStaleAborted", "noDelete", "pcall", "res", "rej", "fmp", "b", "fetchOptions", "forceRefresh", "stale", "isStale", "staleVal", "memoOptions", "vv", "fetching", "#connect", "reason", "#clear", "pi", "ni", "__ssrPromises", "resetConfigure", "configure", "loadCache", "serializeCache", "_regeneratorRuntime", "clearCache", "useAxios", "React", "config", "options"]
}
