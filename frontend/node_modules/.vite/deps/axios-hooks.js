import {
  axios_default,
  isCancel
} from "./chunk-N5LUFGVI.js";
import {
  require_react
} from "./chunk-RY7GF66K.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    function _regeneratorRuntime2() {
      "use strict";
      module.exports = _regeneratorRuntime2 = function _regeneratorRuntime3() {
        return e;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a3 = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define(t2, e2, r2) {
        return Object.defineProperty(t2, e2, {
          value: r2,
          enumerable: true,
          configurable: true,
          writable: true
        }), t2[e2];
      }
      try {
        define({}, "");
      } catch (t2) {
        define = function define2(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a4 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a4, "_invoke", {
          value: makeInvokeMethod(t2, r2, c2)
        }), a4;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return {
            type: "normal",
            arg: t2.call(e2, r2)
          };
        } catch (t3) {
          return {
            type: "throw",
            arg: t3
          };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y2 = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define(p, a3, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a3) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a4) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a4);
            }, function(t3) {
              invoke("throw", t3, i2, a4);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a4);
            });
          }
          a4(c2.arg);
        }
        var r2;
        o(this, "_invoke", {
          value: function value(t3, n2) {
            function callInvokeWithMethodAndArg() {
              return new e2(function(e3, r3) {
                invoke(t3, n2, e3, r3);
              });
            }
            return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a4) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a4;
            return {
              value: t,
              done: true
            };
          }
          for (n2.method = i2, n2.arg = a4; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y2) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y2) continue;
              return {
                value: p2.arg,
                done: n2.done
              };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y2;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y2;
        var a4 = i2.arg;
        return a4 ? a4.done ? (r2[e2.resultName] = a4.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y2) : a4 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y2);
      }
      function pushTryEntry(t2) {
        var e2 = {
          tryLoc: t2[0]
        };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a3];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return {
          __await: t2
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a4 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a4 : a4.next().then(function(t3) {
          return t3.done ? t3.value : a4.next();
        });
      }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a3, function() {
        return this;
      }), define(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(e2) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
        },
        stop: function stop() {
          this.done = true;
          var t2 = this.tryEntries[0].completion;
          if ("throw" === t2.type) throw t2.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(e2) {
          if (this.done) throw e2;
          var r2 = this;
          function handle(n2, o3) {
            return a4.type = "throw", a4.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
          }
          for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
            var i2 = this.tryEntries[o2], a4 = i2.completion;
            if ("root" === i2.tryLoc) return handle("end");
            if (i2.tryLoc <= this.prev) {
              var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
              if (c2 && u2) {
                if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
                if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
              } else if (c2) {
                if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              } else {
                if (!u2) throw Error("try statement without catch or finally");
                if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(t2, e2) {
          for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
            var o2 = this.tryEntries[r2];
            if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
              var i2 = o2;
              break;
            }
          }
          i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
          var a4 = i2 ? i2.completion : {};
          return a4.type = t2, a4.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y2) : this.complete(a4);
        },
        complete: function complete(t2, e2) {
          if ("throw" === t2.type) throw t2.arg;
          return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y2;
        },
        finish: function finish(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y2;
          }
        },
        "catch": function _catch(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.tryLoc === t2) {
              var n2 = r2.completion;
              if ("throw" === n2.type) {
                var o2 = n2.arg;
                resetTryEntry(r2);
              }
              return o2;
            }
          }
          throw Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e2, r2, n2) {
          return this.delegate = {
            iterator: values(e2),
            resultName: r2,
            nextLoc: n2
          }, "next" === this.method && (this.arg = t), y2;
        }
      }, e;
    }
    module.exports = _regeneratorRuntime2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(n, t, e, r, o, a3, c) {
  try {
    var i = n[a3](c), u = i.value;
  } catch (n2) {
    return void e(n2);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function() {
    var t = this, e = arguments;
    return new Promise(function(r, o) {
      var a3 = n.apply(t, e);
      function _next(n2) {
        asyncGeneratorStep(a3, r, o, _next, _throw, "next", n2);
      }
      function _throw(n2) {
        asyncGeneratorStep(a3, r, o, _next, _throw, "throw", n2);
      }
      _next(void 0);
    });
  };
}

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/axios-hooks/es/index.js
var import_regenerator = __toESM(require_regenerator());
var import_react = __toESM(require_react());

// node_modules/axios-hooks/node_modules/lru-cache/dist/esm/index.min.js
var M = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date;
var I = /* @__PURE__ */ new Set();
var R = typeof process == "object" && process ? process : {};
var x = (a3, t, e, i) => {
  typeof R.emitWarning == "function" ? R.emitWarning(a3, t, e, i) : console.error(`[${e}] ${t}: ${a3}`);
};
var C = globalThis.AbortController;
var D = globalThis.AbortSignal;
if (typeof C > "u") {
  D = class {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(i, s) {
      this._onabort.push(s);
    }
  }, C = class {
    constructor() {
      t();
    }
    signal = new D();
    abort(i) {
      if (!this.signal.aborted) {
        this.signal.reason = i, this.signal.aborted = true;
        for (let s of this.signal._onabort) s(i);
        this.signal.onabort?.(i);
      }
    }
  };
  let a3 = R.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1", t = () => {
    a3 && (a3 = false, x("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", t));
  };
}
var G = (a3) => !I.has(a3);
var y = (a3) => a3 && a3 === Math.floor(a3) && a3 > 0 && isFinite(a3);
var U = (a3) => y(a3) ? a3 <= Math.pow(2, 8) ? Uint8Array : a3 <= Math.pow(2, 16) ? Uint16Array : a3 <= Math.pow(2, 32) ? Uint32Array : a3 <= Number.MAX_SAFE_INTEGER ? z : null : null;
var z = class extends Array {
  constructor(t) {
    super(t), this.fill(0);
  }
};
var W = class a {
  heap;
  length;
  static #o = false;
  static create(t) {
    let e = U(t);
    if (!e) return [];
    a.#o = true;
    let i = new a(t, e);
    return a.#o = false, i;
  }
  constructor(t, e) {
    if (!a.#o) throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new e(t), this.length = 0;
  }
  push(t) {
    this.heap[this.length++] = t;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var L = class a2 {
  #o;
  #c;
  #w;
  #C;
  #S;
  #L;
  #I;
  #m;
  get perf() {
    return this.#m;
  }
  ttl;
  ttlResolution;
  ttlAutopurge;
  updateAgeOnGet;
  updateAgeOnHas;
  allowStale;
  noDisposeOnSet;
  noUpdateTTL;
  maxEntrySize;
  sizeCalculation;
  noDeleteOnFetchRejection;
  noDeleteOnStaleGet;
  allowStaleOnFetchAbort;
  allowStaleOnFetchRejection;
  ignoreFetchAbort;
  #n;
  #_;
  #s;
  #i;
  #t;
  #a;
  #u;
  #l;
  #h;
  #b;
  #r;
  #y;
  #A;
  #d;
  #g;
  #T;
  #v;
  #f;
  #x;
  static unsafeExposeInternals(t) {
    return { starts: t.#A, ttls: t.#d, autopurgeTimers: t.#g, sizes: t.#y, keyMap: t.#s, keyList: t.#i, valList: t.#t, next: t.#a, prev: t.#u, get head() {
      return t.#l;
    }, get tail() {
      return t.#h;
    }, free: t.#b, isBackgroundFetch: (e) => t.#e(e), backgroundFetch: (e, i, s, h) => t.#G(e, i, s, h), moveToTail: (e) => t.#D(e), indexes: (e) => t.#F(e), rindexes: (e) => t.#O(e), isStale: (e) => t.#p(e) };
  }
  get max() {
    return this.#o;
  }
  get maxSize() {
    return this.#c;
  }
  get calculatedSize() {
    return this.#_;
  }
  get size() {
    return this.#n;
  }
  get fetchMethod() {
    return this.#L;
  }
  get memoMethod() {
    return this.#I;
  }
  get dispose() {
    return this.#w;
  }
  get onInsert() {
    return this.#C;
  }
  get disposeAfter() {
    return this.#S;
  }
  constructor(t) {
    let { max: e = 0, ttl: i, ttlResolution: s = 1, ttlAutopurge: h, updateAgeOnGet: n, updateAgeOnHas: o, allowStale: r, dispose: f, onInsert: m, disposeAfter: c, noDisposeOnSet: d, noUpdateTTL: g, maxSize: A = 0, maxEntrySize: p = 0, sizeCalculation: _, fetchMethod: l, memoMethod: w, noDeleteOnFetchRejection: b, noDeleteOnStaleGet: S, allowStaleOnFetchRejection: u, allowStaleOnFetchAbort: T, ignoreFetchAbort: F, perf: v } = t;
    if (v !== void 0 && typeof v?.now != "function") throw new TypeError("perf option must have a now() method if specified");
    if (this.#m = v ?? M, e !== 0 && !y(e)) throw new TypeError("max option must be a nonnegative integer");
    let O = e ? U(e) : Array;
    if (!O) throw new Error("invalid max value: " + e);
    if (this.#o = e, this.#c = A, this.maxEntrySize = p || this.#c, this.sizeCalculation = _, this.sizeCalculation) {
      if (!this.#c && !this.maxEntrySize) throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function") throw new TypeError("sizeCalculation set to non-function");
    }
    if (w !== void 0 && typeof w != "function") throw new TypeError("memoMethod must be a function if defined");
    if (this.#I = w, l !== void 0 && typeof l != "function") throw new TypeError("fetchMethod must be a function if specified");
    if (this.#L = l, this.#v = !!l, this.#s = /* @__PURE__ */ new Map(), this.#i = new Array(e).fill(void 0), this.#t = new Array(e).fill(void 0), this.#a = new O(e), this.#u = new O(e), this.#l = 0, this.#h = 0, this.#b = W.create(e), this.#n = 0, this.#_ = 0, typeof f == "function" && (this.#w = f), typeof m == "function" && (this.#C = m), typeof c == "function" ? (this.#S = c, this.#r = []) : (this.#S = void 0, this.#r = void 0), this.#T = !!this.#w, this.#x = !!this.#C, this.#f = !!this.#S, this.noDisposeOnSet = !!d, this.noUpdateTTL = !!g, this.noDeleteOnFetchRejection = !!b, this.allowStaleOnFetchRejection = !!u, this.allowStaleOnFetchAbort = !!T, this.ignoreFetchAbort = !!F, this.maxEntrySize !== 0) {
      if (this.#c !== 0 && !y(this.#c)) throw new TypeError("maxSize must be a positive integer if specified");
      if (!y(this.maxEntrySize)) throw new TypeError("maxEntrySize must be a positive integer if specified");
      this.#B();
    }
    if (this.allowStale = !!r, this.noDeleteOnStaleGet = !!S, this.updateAgeOnGet = !!n, this.updateAgeOnHas = !!o, this.ttlResolution = y(s) || s === 0 ? s : 1, this.ttlAutopurge = !!h, this.ttl = i || 0, this.ttl) {
      if (!y(this.ttl)) throw new TypeError("ttl must be a positive integer if specified");
      this.#j();
    }
    if (this.#o === 0 && this.ttl === 0 && this.#c === 0) throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !this.#o && !this.#c) {
      let E = "LRU_CACHE_UNBOUNDED";
      G(E) && (I.add(E), x("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", E, a2));
    }
  }
  getRemainingTTL(t) {
    return this.#s.has(t) ? 1 / 0 : 0;
  }
  #j() {
    let t = new z(this.#o), e = new z(this.#o);
    this.#d = t, this.#A = e;
    let i = this.ttlAutopurge ? new Array(this.#o) : void 0;
    this.#g = i, this.#N = (n, o, r = this.#m.now()) => {
      if (e[n] = o !== 0 ? r : 0, t[n] = o, i?.[n] && (clearTimeout(i[n]), i[n] = void 0), o !== 0 && i) {
        let f = setTimeout(() => {
          this.#p(n) && this.#E(this.#i[n], "expire");
        }, o + 1);
        f.unref && f.unref(), i[n] = f;
      }
    }, this.#R = (n) => {
      e[n] = t[n] !== 0 ? this.#m.now() : 0;
    }, this.#z = (n, o) => {
      if (t[o]) {
        let r = t[o], f = e[o];
        if (!r || !f) return;
        n.ttl = r, n.start = f, n.now = s || h();
        let m = n.now - f;
        n.remainingTTL = r - m;
      }
    };
    let s = 0, h = () => {
      let n = this.#m.now();
      if (this.ttlResolution > 0) {
        s = n;
        let o = setTimeout(() => s = 0, this.ttlResolution);
        o.unref && o.unref();
      }
      return n;
    };
    this.getRemainingTTL = (n) => {
      let o = this.#s.get(n);
      if (o === void 0) return 0;
      let r = t[o], f = e[o];
      if (!r || !f) return 1 / 0;
      let m = (s || h()) - f;
      return r - m;
    }, this.#p = (n) => {
      let o = e[n], r = t[n];
      return !!r && !!o && (s || h()) - o > r;
    };
  }
  #R = () => {
  };
  #z = () => {
  };
  #N = () => {
  };
  #p = () => false;
  #B() {
    let t = new z(this.#o);
    this.#_ = 0, this.#y = t, this.#W = (e) => {
      this.#_ -= t[e], t[e] = 0;
    }, this.#P = (e, i, s, h) => {
      if (this.#e(i)) return 0;
      if (!y(s)) if (h) {
        if (typeof h != "function") throw new TypeError("sizeCalculation must be a function");
        if (s = h(i, e), !y(s)) throw new TypeError("sizeCalculation return invalid (expect positive integer)");
      } else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      return s;
    }, this.#U = (e, i, s) => {
      if (t[e] = i, this.#c) {
        let h = this.#c - t[e];
        for (; this.#_ > h; ) this.#M(true);
      }
      this.#_ += t[e], s && (s.entrySize = i, s.totalCalculatedSize = this.#_);
    };
  }
  #W = (t) => {
  };
  #U = (t, e, i) => {
  };
  #P = (t, e, i, s) => {
    if (i || s) throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    return 0;
  };
  *#F({ allowStale: t = this.allowStale } = {}) {
    if (this.#n) for (let e = this.#h; !(!this.#H(e) || ((t || !this.#p(e)) && (yield e), e === this.#l)); ) e = this.#u[e];
  }
  *#O({ allowStale: t = this.allowStale } = {}) {
    if (this.#n) for (let e = this.#l; !(!this.#H(e) || ((t || !this.#p(e)) && (yield e), e === this.#h)); ) e = this.#a[e];
  }
  #H(t) {
    return t !== void 0 && this.#s.get(this.#i[t]) === t;
  }
  *entries() {
    for (let t of this.#F()) this.#t[t] !== void 0 && this.#i[t] !== void 0 && !this.#e(this.#t[t]) && (yield [this.#i[t], this.#t[t]]);
  }
  *rentries() {
    for (let t of this.#O()) this.#t[t] !== void 0 && this.#i[t] !== void 0 && !this.#e(this.#t[t]) && (yield [this.#i[t], this.#t[t]]);
  }
  *keys() {
    for (let t of this.#F()) {
      let e = this.#i[t];
      e !== void 0 && !this.#e(this.#t[t]) && (yield e);
    }
  }
  *rkeys() {
    for (let t of this.#O()) {
      let e = this.#i[t];
      e !== void 0 && !this.#e(this.#t[t]) && (yield e);
    }
  }
  *values() {
    for (let t of this.#F()) this.#t[t] !== void 0 && !this.#e(this.#t[t]) && (yield this.#t[t]);
  }
  *rvalues() {
    for (let t of this.#O()) this.#t[t] !== void 0 && !this.#e(this.#t[t]) && (yield this.#t[t]);
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  [Symbol.toStringTag] = "LRUCache";
  find(t, e = {}) {
    for (let i of this.#F()) {
      let s = this.#t[i], h = this.#e(s) ? s.__staleWhileFetching : s;
      if (h !== void 0 && t(h, this.#i[i], this)) return this.get(this.#i[i], e);
    }
  }
  forEach(t, e = this) {
    for (let i of this.#F()) {
      let s = this.#t[i], h = this.#e(s) ? s.__staleWhileFetching : s;
      h !== void 0 && t.call(e, h, this.#i[i], this);
    }
  }
  rforEach(t, e = this) {
    for (let i of this.#O()) {
      let s = this.#t[i], h = this.#e(s) ? s.__staleWhileFetching : s;
      h !== void 0 && t.call(e, h, this.#i[i], this);
    }
  }
  purgeStale() {
    let t = false;
    for (let e of this.#O({ allowStale: true })) this.#p(e) && (this.#E(this.#i[e], "expire"), t = true);
    return t;
  }
  info(t) {
    let e = this.#s.get(t);
    if (e === void 0) return;
    let i = this.#t[e], s = this.#e(i) ? i.__staleWhileFetching : i;
    if (s === void 0) return;
    let h = { value: s };
    if (this.#d && this.#A) {
      let n = this.#d[e], o = this.#A[e];
      if (n && o) {
        let r = n - (this.#m.now() - o);
        h.ttl = r, h.start = Date.now();
      }
    }
    return this.#y && (h.size = this.#y[e]), h;
  }
  dump() {
    let t = [];
    for (let e of this.#F({ allowStale: true })) {
      let i = this.#i[e], s = this.#t[e], h = this.#e(s) ? s.__staleWhileFetching : s;
      if (h === void 0 || i === void 0) continue;
      let n = { value: h };
      if (this.#d && this.#A) {
        n.ttl = this.#d[e];
        let o = this.#m.now() - this.#A[e];
        n.start = Math.floor(Date.now() - o);
      }
      this.#y && (n.size = this.#y[e]), t.unshift([i, n]);
    }
    return t;
  }
  load(t) {
    this.clear();
    for (let [e, i] of t) {
      if (i.start) {
        let s = Date.now() - i.start;
        i.start = this.#m.now() - s;
      }
      this.set(e, i.value, i);
    }
  }
  set(t, e, i = {}) {
    if (e === void 0) return this.delete(t), this;
    let { ttl: s = this.ttl, start: h, noDisposeOnSet: n = this.noDisposeOnSet, sizeCalculation: o = this.sizeCalculation, status: r } = i, { noUpdateTTL: f = this.noUpdateTTL } = i, m = this.#P(t, e, i.size || 0, o);
    if (this.maxEntrySize && m > this.maxEntrySize) return r && (r.set = "miss", r.maxEntrySizeExceeded = true), this.#E(t, "set"), this;
    let c = this.#n === 0 ? void 0 : this.#s.get(t);
    if (c === void 0) c = this.#n === 0 ? this.#h : this.#b.length !== 0 ? this.#b.pop() : this.#n === this.#o ? this.#M(false) : this.#n, this.#i[c] = t, this.#t[c] = e, this.#s.set(t, c), this.#a[this.#h] = c, this.#u[c] = this.#h, this.#h = c, this.#n++, this.#U(c, m, r), r && (r.set = "add"), f = false, this.#x && this.#C?.(e, t, "add");
    else {
      this.#D(c);
      let d = this.#t[c];
      if (e !== d) {
        if (this.#v && this.#e(d)) {
          d.__abortController.abort(new Error("replaced"));
          let { __staleWhileFetching: g } = d;
          g !== void 0 && !n && (this.#T && this.#w?.(g, t, "set"), this.#f && this.#r?.push([g, t, "set"]));
        } else n || (this.#T && this.#w?.(d, t, "set"), this.#f && this.#r?.push([d, t, "set"]));
        if (this.#W(c), this.#U(c, m, r), this.#t[c] = e, r) {
          r.set = "replace";
          let g = d && this.#e(d) ? d.__staleWhileFetching : d;
          g !== void 0 && (r.oldValue = g);
        }
      } else r && (r.set = "update");
      this.#x && this.onInsert?.(e, t, e === d ? "update" : "replace");
    }
    if (s !== 0 && !this.#d && this.#j(), this.#d && (f || this.#N(c, s, h), r && this.#z(r, c)), !n && this.#f && this.#r) {
      let d = this.#r, g;
      for (; g = d?.shift(); ) this.#S?.(...g);
    }
    return this;
  }
  pop() {
    try {
      for (; this.#n; ) {
        let t = this.#t[this.#l];
        if (this.#M(true), this.#e(t)) {
          if (t.__staleWhileFetching) return t.__staleWhileFetching;
        } else if (t !== void 0) return t;
      }
    } finally {
      if (this.#f && this.#r) {
        let t = this.#r, e;
        for (; e = t?.shift(); ) this.#S?.(...e);
      }
    }
  }
  #M(t) {
    let e = this.#l, i = this.#i[e], s = this.#t[e];
    return this.#v && this.#e(s) ? s.__abortController.abort(new Error("evicted")) : (this.#T || this.#f) && (this.#T && this.#w?.(s, i, "evict"), this.#f && this.#r?.push([s, i, "evict"])), this.#W(e), this.#g?.[e] && (clearTimeout(this.#g[e]), this.#g[e] = void 0), t && (this.#i[e] = void 0, this.#t[e] = void 0, this.#b.push(e)), this.#n === 1 ? (this.#l = this.#h = 0, this.#b.length = 0) : this.#l = this.#a[e], this.#s.delete(i), this.#n--, e;
  }
  has(t, e = {}) {
    let { updateAgeOnHas: i = this.updateAgeOnHas, status: s } = e, h = this.#s.get(t);
    if (h !== void 0) {
      let n = this.#t[h];
      if (this.#e(n) && n.__staleWhileFetching === void 0) return false;
      if (this.#p(h)) s && (s.has = "stale", this.#z(s, h));
      else return i && this.#R(h), s && (s.has = "hit", this.#z(s, h)), true;
    } else s && (s.has = "miss");
    return false;
  }
  peek(t, e = {}) {
    let { allowStale: i = this.allowStale } = e, s = this.#s.get(t);
    if (s === void 0 || !i && this.#p(s)) return;
    let h = this.#t[s];
    return this.#e(h) ? h.__staleWhileFetching : h;
  }
  #G(t, e, i, s) {
    let h = e === void 0 ? void 0 : this.#t[e];
    if (this.#e(h)) return h;
    let n = new C(), { signal: o } = i;
    o?.addEventListener("abort", () => n.abort(o.reason), { signal: n.signal });
    let r = { signal: n.signal, options: i, context: s }, f = (p, _ = false) => {
      let { aborted: l } = n.signal, w = i.ignoreFetchAbort && p !== void 0, b = i.ignoreFetchAbort || !!(i.allowStaleOnFetchAbort && p !== void 0);
      if (i.status && (l && !_ ? (i.status.fetchAborted = true, i.status.fetchError = n.signal.reason, w && (i.status.fetchAbortIgnored = true)) : i.status.fetchResolved = true), l && !w && !_) return c(n.signal.reason, b);
      let S = g, u = this.#t[e];
      return (u === g || w && _ && u === void 0) && (p === void 0 ? S.__staleWhileFetching !== void 0 ? this.#t[e] = S.__staleWhileFetching : this.#E(t, "fetch") : (i.status && (i.status.fetchUpdated = true), this.set(t, p, r.options))), p;
    }, m = (p) => (i.status && (i.status.fetchRejected = true, i.status.fetchError = p), c(p, false)), c = (p, _) => {
      let { aborted: l } = n.signal, w = l && i.allowStaleOnFetchAbort, b = w || i.allowStaleOnFetchRejection, S = b || i.noDeleteOnFetchRejection, u = g;
      if (this.#t[e] === g && (!S || !_ && u.__staleWhileFetching === void 0 ? this.#E(t, "fetch") : w || (this.#t[e] = u.__staleWhileFetching)), b) return i.status && u.__staleWhileFetching !== void 0 && (i.status.returnedStale = true), u.__staleWhileFetching;
      if (u.__returned === u) throw p;
    }, d = (p, _) => {
      let l = this.#L?.(t, h, r);
      l && l instanceof Promise && l.then((w) => p(w === void 0 ? void 0 : w), _), n.signal.addEventListener("abort", () => {
        (!i.ignoreFetchAbort || i.allowStaleOnFetchAbort) && (p(void 0), i.allowStaleOnFetchAbort && (p = (w) => f(w, true)));
      });
    };
    i.status && (i.status.fetchDispatched = true);
    let g = new Promise(d).then(f, m), A = Object.assign(g, { __abortController: n, __staleWhileFetching: h, __returned: void 0 });
    return e === void 0 ? (this.set(t, A, { ...r.options, status: void 0 }), e = this.#s.get(t)) : this.#t[e] = A, A;
  }
  #e(t) {
    if (!this.#v) return false;
    let e = t;
    return !!e && e instanceof Promise && e.hasOwnProperty("__staleWhileFetching") && e.__abortController instanceof C;
  }
  async fetch(t, e = {}) {
    let { allowStale: i = this.allowStale, updateAgeOnGet: s = this.updateAgeOnGet, noDeleteOnStaleGet: h = this.noDeleteOnStaleGet, ttl: n = this.ttl, noDisposeOnSet: o = this.noDisposeOnSet, size: r = 0, sizeCalculation: f = this.sizeCalculation, noUpdateTTL: m = this.noUpdateTTL, noDeleteOnFetchRejection: c = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection: d = this.allowStaleOnFetchRejection, ignoreFetchAbort: g = this.ignoreFetchAbort, allowStaleOnFetchAbort: A = this.allowStaleOnFetchAbort, context: p, forceRefresh: _ = false, status: l, signal: w } = e;
    if (!this.#v) return l && (l.fetch = "get"), this.get(t, { allowStale: i, updateAgeOnGet: s, noDeleteOnStaleGet: h, status: l });
    let b = { allowStale: i, updateAgeOnGet: s, noDeleteOnStaleGet: h, ttl: n, noDisposeOnSet: o, size: r, sizeCalculation: f, noUpdateTTL: m, noDeleteOnFetchRejection: c, allowStaleOnFetchRejection: d, allowStaleOnFetchAbort: A, ignoreFetchAbort: g, status: l, signal: w }, S = this.#s.get(t);
    if (S === void 0) {
      l && (l.fetch = "miss");
      let u = this.#G(t, S, b, p);
      return u.__returned = u;
    } else {
      let u = this.#t[S];
      if (this.#e(u)) {
        let E = i && u.__staleWhileFetching !== void 0;
        return l && (l.fetch = "inflight", E && (l.returnedStale = true)), E ? u.__staleWhileFetching : u.__returned = u;
      }
      let T = this.#p(S);
      if (!_ && !T) return l && (l.fetch = "hit"), this.#D(S), s && this.#R(S), l && this.#z(l, S), u;
      let F = this.#G(t, S, b, p), O = F.__staleWhileFetching !== void 0 && i;
      return l && (l.fetch = T ? "stale" : "refresh", O && T && (l.returnedStale = true)), O ? F.__staleWhileFetching : F.__returned = F;
    }
  }
  async forceFetch(t, e = {}) {
    let i = await this.fetch(t, e);
    if (i === void 0) throw new Error("fetch() returned undefined");
    return i;
  }
  memo(t, e = {}) {
    let i = this.#I;
    if (!i) throw new Error("no memoMethod provided to constructor");
    let { context: s, forceRefresh: h, ...n } = e, o = this.get(t, n);
    if (!h && o !== void 0) return o;
    let r = i(t, o, { options: n, context: s });
    return this.set(t, r, n), r;
  }
  get(t, e = {}) {
    let { allowStale: i = this.allowStale, updateAgeOnGet: s = this.updateAgeOnGet, noDeleteOnStaleGet: h = this.noDeleteOnStaleGet, status: n } = e, o = this.#s.get(t);
    if (o !== void 0) {
      let r = this.#t[o], f = this.#e(r);
      return n && this.#z(n, o), this.#p(o) ? (n && (n.get = "stale"), f ? (n && i && r.__staleWhileFetching !== void 0 && (n.returnedStale = true), i ? r.__staleWhileFetching : void 0) : (h || this.#E(t, "expire"), n && i && (n.returnedStale = true), i ? r : void 0)) : (n && (n.get = "hit"), f ? r.__staleWhileFetching : (this.#D(o), s && this.#R(o), r));
    } else n && (n.get = "miss");
  }
  #k(t, e) {
    this.#u[e] = t, this.#a[t] = e;
  }
  #D(t) {
    t !== this.#h && (t === this.#l ? this.#l = this.#a[t] : this.#k(this.#u[t], this.#a[t]), this.#k(this.#h, t), this.#h = t);
  }
  delete(t) {
    return this.#E(t, "delete");
  }
  #E(t, e) {
    let i = false;
    if (this.#n !== 0) {
      let s = this.#s.get(t);
      if (s !== void 0) if (this.#g?.[s] && (clearTimeout(this.#g?.[s]), this.#g[s] = void 0), i = true, this.#n === 1) this.#V(e);
      else {
        this.#W(s);
        let h = this.#t[s];
        if (this.#e(h) ? h.__abortController.abort(new Error("deleted")) : (this.#T || this.#f) && (this.#T && this.#w?.(h, t, e), this.#f && this.#r?.push([h, t, e])), this.#s.delete(t), this.#i[s] = void 0, this.#t[s] = void 0, s === this.#h) this.#h = this.#u[s];
        else if (s === this.#l) this.#l = this.#a[s];
        else {
          let n = this.#u[s];
          this.#a[n] = this.#a[s];
          let o = this.#a[s];
          this.#u[o] = this.#u[s];
        }
        this.#n--, this.#b.push(s);
      }
    }
    if (this.#f && this.#r?.length) {
      let s = this.#r, h;
      for (; h = s?.shift(); ) this.#S?.(...h);
    }
    return i;
  }
  clear() {
    return this.#V("delete");
  }
  #V(t) {
    for (let e of this.#O({ allowStale: true })) {
      let i = this.#t[e];
      if (this.#e(i)) i.__abortController.abort(new Error("deleted"));
      else {
        let s = this.#i[e];
        this.#T && this.#w?.(i, s, t), this.#f && this.#r?.push([i, s, t]);
      }
    }
    if (this.#s.clear(), this.#t.fill(void 0), this.#i.fill(void 0), this.#d && this.#A) {
      this.#d.fill(0), this.#A.fill(0);
      for (let e of this.#g ?? []) e !== void 0 && clearTimeout(e);
      this.#g?.fill(void 0);
    }
    if (this.#y && this.#y.fill(0), this.#l = 0, this.#h = 0, this.#b.length = 0, this.#_ = 0, this.#n = 0, this.#f && this.#r) {
      let e = this.#r, i;
      for (; i = e?.shift(); ) this.#S?.(...i);
    }
  }
};

// node_modules/dequal/lite/index.mjs
var has = Object.prototype.hasOwnProperty;
function dequal(foo, bar) {
  var ctor, len;
  if (foo === bar) return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len])) ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/axios-hooks/es/index.js
var actions = {
  REQUEST_START: "REQUEST_START",
  REQUEST_END: "REQUEST_END"
};
var DEFAULT_OPTIONS = {
  manual: false,
  useCache: true,
  ssr: true,
  autoCancel: true
};
var useAxios = makeUseAxios();
var __ssrPromises = useAxios.__ssrPromises;
var resetConfigure = useAxios.resetConfigure;
var configure = useAxios.configure;
var loadCache = useAxios.loadCache;
var serializeCache = useAxios.serializeCache;
var clearCache = useAxios.clearCache;
var es_default = useAxios;
function isReactEvent(obj) {
  return obj && obj.nativeEvent && obj.nativeEvent instanceof Event;
}
function createCacheKey(config) {
  var cleanedConfig = _extends({}, config);
  delete cleanedConfig.cancelToken;
  return JSON.stringify(cleanedConfig);
}
function configToObject(config) {
  if (typeof config === "string") {
    return {
      url: config
    };
  }
  return Object.assign({}, config);
}
function makeUseAxios(configureOptions) {
  var cache;
  var axiosInstance;
  var defaultOptions;
  var __ssrPromises2 = [];
  function resetConfigure2() {
    cache = new L({
      max: 500
    });
    axiosInstance = axios_default;
    defaultOptions = DEFAULT_OPTIONS;
  }
  function configure2(options) {
    if (options === void 0) {
      options = {};
    }
    if (options.axios !== void 0) {
      axiosInstance = options.axios;
    }
    if (options.cache !== void 0) {
      cache = options.cache;
    }
    if (options.defaultOptions !== void 0) {
      defaultOptions = _extends({}, DEFAULT_OPTIONS, options.defaultOptions);
    }
  }
  resetConfigure2();
  configure2(configureOptions);
  function loadCache2(data) {
    cache.load(data);
  }
  function serializeCache2() {
    return _serializeCache.apply(this, arguments);
  }
  function _serializeCache() {
    _serializeCache = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
      var ssrPromisesCopy;
      return import_regenerator.default.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            ssrPromisesCopy = [].concat(__ssrPromises2);
            __ssrPromises2.length = 0;
            _context.next = 4;
            return Promise.all(ssrPromisesCopy);
          case 4:
            return _context.abrupt("return", cache.dump());
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _serializeCache.apply(this, arguments);
  }
  function clearCache2() {
    cache.clear();
  }
  return Object.assign(useAxios2, {
    __ssrPromises: __ssrPromises2,
    resetConfigure: resetConfigure2,
    configure: configure2,
    loadCache: loadCache2,
    serializeCache: serializeCache2,
    clearCache: clearCache2
  });
  function tryStoreInCache(config, response) {
    if (!cache) {
      return;
    }
    var cacheKey = createCacheKey(config);
    var responseForCache = _extends({}, response);
    delete responseForCache.config;
    delete responseForCache.request;
    cache.set(cacheKey, responseForCache);
  }
  function createInitialState(config, options) {
    var response = !options.manual && tryGetFromCache(config, options);
    return _extends({
      loading: !options.manual && !response,
      error: null
    }, response ? {
      data: response.data,
      response
    } : null);
  }
  function reducer(state, action) {
    var _extends2;
    switch (action.type) {
      case actions.REQUEST_START:
        return _extends({}, state, {
          loading: true,
          error: null
        });
      case actions.REQUEST_END:
        return _extends({}, state, {
          loading: false
        }, action.error ? {} : {
          data: action.payload.data,
          error: null
        }, (_extends2 = {}, _extends2[action.error ? "error" : "response"] = action.payload, _extends2));
    }
  }
  function tryGetFromCache(config, options, dispatch) {
    if (!cache || !options.useCache) {
      return;
    }
    var cacheKey = createCacheKey(config);
    var response = cache.get(cacheKey);
    if (response && dispatch) {
      dispatch({
        type: actions.REQUEST_END,
        payload: response
      });
    }
    return response;
  }
  function executeRequest(_x, _x2) {
    return _executeRequest.apply(this, arguments);
  }
  function _executeRequest() {
    _executeRequest = _asyncToGenerator(import_regenerator.default.mark(function _callee2(config, dispatch) {
      var response;
      return import_regenerator.default.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            dispatch({
              type: actions.REQUEST_START
            });
            _context2.next = 4;
            return axiosInstance(config);
          case 4:
            response = _context2.sent;
            tryStoreInCache(config, response);
            dispatch({
              type: actions.REQUEST_END,
              payload: response
            });
            return _context2.abrupt("return", response);
          case 10:
            _context2.prev = 10;
            _context2.t0 = _context2["catch"](0);
            if (!isCancel(_context2.t0)) {
              dispatch({
                type: actions.REQUEST_END,
                payload: _context2.t0,
                error: true
              });
            }
            throw _context2.t0;
          case 14:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[0, 10]]);
    }));
    return _executeRequest.apply(this, arguments);
  }
  function request(_x3, _x4, _x5) {
    return _request.apply(this, arguments);
  }
  function _request() {
    _request = _asyncToGenerator(import_regenerator.default.mark(function _callee3(config, options, dispatch) {
      return import_regenerator.default.wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", tryGetFromCache(config, options, dispatch) || executeRequest(config, dispatch));
          case 1:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return _request.apply(this, arguments);
  }
  function useAxios2(_config, _options) {
    var config = import_react.default.useMemo(
      function() {
        return configToObject(_config);
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      useDeepCompareMemoize(_config)
    );
    var options = import_react.default.useMemo(
      function() {
        return _extends({}, defaultOptions, _options);
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      useDeepCompareMemoize(_options)
    );
    var abortControllerRef = import_react.default.useRef();
    var _React$useReducer = import_react.default.useReducer(reducer, createInitialState(config, options)), state = _React$useReducer[0], dispatch = _React$useReducer[1];
    if (typeof window === "undefined" && options.ssr && !options.manual) {
      useAxios2.__ssrPromises.push(axiosInstance(config));
    }
    var cancelOutstandingRequest = import_react.default.useCallback(function() {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    }, []);
    var withAbortSignal = import_react.default.useCallback(function(config2) {
      if (options.autoCancel) {
        cancelOutstandingRequest();
      }
      abortControllerRef.current = new AbortController();
      config2.signal = abortControllerRef.current.signal;
      return config2;
    }, [cancelOutstandingRequest, options.autoCancel]);
    import_react.default.useEffect(function() {
      if (!options.manual) {
        request(withAbortSignal(config), options, dispatch)["catch"](function() {
        });
      }
      return function() {
        if (options.autoCancel) {
          cancelOutstandingRequest();
        }
      };
    }, [config, options, withAbortSignal, cancelOutstandingRequest]);
    var refetch = import_react.default.useCallback(function(configOverride, options2) {
      configOverride = configToObject(configOverride);
      return request(withAbortSignal(_extends({}, config, isReactEvent(configOverride) ? null : configOverride)), _extends({
        useCache: false
      }, options2), dispatch);
    }, [config, withAbortSignal]);
    return [state, refetch, cancelOutstandingRequest];
  }
}
function useDeepCompareMemoize(value) {
  var ref = import_react.default.useRef();
  var signalRef = import_react.default.useRef(0);
  if (!dequal(value, ref.current)) {
    ref.current = value;
    signalRef.current += 1;
  }
  return [signalRef.current];
}
export {
  __ssrPromises,
  clearCache,
  configure,
  es_default as default,
  loadCache,
  makeUseAxios,
  resetConfigure,
  serializeCache
};
//# sourceMappingURL=axios-hooks.js.map
